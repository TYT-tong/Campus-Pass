## 目标
- 第二次查询仍出现 `ArrayList cannot be cast to JSONArray`，说明运行中的路径仍可能触发对 `JSONArray` 的直接转换。
- 通过调整 `DictUtils.getDictCache`，完全移除 `JSONArray` 强转分支，改为字符串与通用对象解析，彻底规避该类异常。

## 修改点
- 文件：`cp-common/cp-common-security/src/main/java/com/cp/common/security/utils/DictUtils.java`
- 方法：`getDictCache(String key)`
- 变更：
  - 保留 `List<?>` 分支处理（已实现），用于 `ArrayList<LinkedHashMap>` 场景。
  - 移除 `cache instanceof JSONArray` 分支，避免任何 `JSONArray` 强转。
  - 新增 `cache instanceof String` 分支，使用 `JSON.parseArray((String) cache, SysDictData.class)` 解析旧缓存为字符串的情况。
  - 最后增加通用兜底：将 `cache` 转为 JSON 字符串，再 `parseArray` 尝试解析为 `List<SysDictData>`。

## 验证
- 重新打包并重启 `cp-system`；再次调用 `GET /dict/data/type/sys_user_sex`：
  - 第一次走 DB 并写入缓存；第二次命中缓存直接返回。
  - 不再出现 `ClassCastException`。

## 说明
- 已清理 Redis 缓存是正确步骤；本次修改确保新写入与旧结构均可解析。